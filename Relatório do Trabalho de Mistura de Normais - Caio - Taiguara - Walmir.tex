\documentclass[12pt,reqno,a4paper,oneside]{article}

\usepackage{amsfonts, amsmath,
	        amssymb, amsthm}  % Fontes e símbolos matemáticos da AMS.
\usepackage{graphicx}         % Importação de gráficos.
\usepackage{subfig}
\usepackage[brazil]{babel}    % Idioma português (Brasil) como padrão.
\usepackage[utf8]{inputenc}   % Codificação UTF-8.
%\usepackage{natbib}           % Para citações.
%\usepackage{cite}             % Idem.

\usepackage{bm}          % Equações em negrito com qualidade superior.
\usepackage{booktabs}    % Edição de linhas de tabelas.
\usepackage{caption}     % Edição do texto dos títulos de tabelas.
\usepackage{color}       % Edição de cores.
\usepackage{indentfirst} % Indentará sempre o 1º parágrafo de cada seção do relatório.
%\usepackage{enumitem}   % Edição mais elaborada de listas
                         % Conflito com ambiente "enumerate" no beamer!.
%\usepackage{hyperref}   % Criação de "hyperlinks".
\usepackage{multirow}    % Para obter uma célula com uma coluna e várias linhas.
\usepackage{ragged2e}    % Opções de alinhamento do texto.

%\usepackage[FIGTOPCAP]{subfigure} % Acesso a figuras dentro de pastas.

\usepackage[top=2cm, bottom=2cm,
            left=2cm, right=2cm]{geometry} % Margens do texto.

\captionsetup{justification = centering} % Centraliza os títulos das tabelas.

% Símbolo matemático para independência entre variáveis aleatórias:

\newcommand\indep{\protect\mathpalette{\protect\independenT}{\perp}}\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}

\begin{document}

\title{\huge Relatório do Trabalho de\\
	Estatística Bayesiana I}
\author{\\
	\\
	\huge Mistura de Normais\\
	\huge com Variância Contaminada\\
	\\
	\\
	\\
	\\
	\Large Caio Balieiro\\
	\Large Taiguara Melo Tupinambás\\
	\Large Walmir dos Reis Miranda Filho\\
	\\
	\\
	\\
	\\
	\Large Prof. Dani Gamerman\\
	\Large Profª Rosangela Helena Loschi\\
	\\
	\\
	\\
	\\
	\\
	Programa de Pós-Graduação em Estatística\\
	Instituto de Ciências Exatas\\
	Universidade Federal de Minas Gerais\\
	\\
	\\
	\\
	\\
	\\
	\\}
\date{Belo Horizonte, 2 de dezembro de 2019}
\maketitle

\newpage

\input{sec1introRT.tex}
\input{sec2qrRT.tex}

\section{O Método da Reamostragem Por Importância Sequencial (SIR)}\label{sir}

%Texto descrevendo o método e como foi feita neste trabalho a geração de variáveis aleatórias da distribuição de interesse usando este mesmo método.

\section{O Método de Monte Carlo via Cadeias de Markov (MCMC)}\label{mcmc}

%Texto descrevendo o método e como foi feita neste trabalho a geração de variáveis aleatórias da distribuição de interesse usando este mesmo método, bem como o amostrador selecionado (possivelmente Gibbs ou outro que for de melhor uso para todo o grupo).

\section{Considerações Finais}\label{consfin}

%Texto descrevendo de forma resumida o que foi feito nas seções anteriores, bem como os resultados dos métodos quanto à convergência, à medida que se aumenta o tamanho amostral m da distribuição \textit{a poseteriori}.

\bibliographystyle{unsrt}
\bibliography{ref}

\newpage

\section*{Apêndice: Código R para os Resultados Apresentados}

\subsection*{Introdução}

\begin{verbatim}
# Tamanho amostral "n"; parâmetros "mu", "s2" (sigma^2) e "nu" do modelo para
# a distribuição amostral e hiperparâmetros m, V, a e d das distribuições "a
# priori" (somente para "mu" e "s2"):

n = 500; mu = 11; s2 = 0.64; nu = 0.2; m = 11; V = 1; a = 7; d = 4

# Geração hierárquica da amostra de tamanho "n" do modelo:

U_pdf = function(n, nu) {
	u = sample(c(100, 1), prob=c(nu, 1-nu), size=n, replace=T)
}

set.seed(122019)

u = U_pdf(n, nu)
sam = rnorm(n, mu, sqrt(s2*u))

# Histograma da amostra gerada do modelo (figura 1):

par(mar = c(5,5,3,2))
hist(sam, breaks=100, prob=T, main="", xlim = c(-10, 40), ylim = c(0, 0.5),
	 xlab = "Amostra do modelo", ylab = "Densidade empírica")

# Cálculo do logaritmo do núcleo da distribuição "a posteriori" original:

logA = function(X, mu, sigma2, nu) {
	n = length(X)
	k1 = (nu/10)*exp(-(X-mu)^2/(2*100*sigma2))
	k2 = (1-nu)*exp(-(X-mu)^2/(2*sigma2))
	k = log(k1 + k2)
	return(k)
}

logh = function(n, mu, sigma2, nu, m, V, a, d) {
	k1 = -((n + 1)/2 + a + 1)*log(sigma2)
	k2 = -((mu - m)^2/(2*V) + d)/sigma2
	k = k1 + k2
	return(k)
}

logkpost = function(X, mu, sigma2, nu, m, V, a, d) {
	n = length(X)
	lA = logA(X, mu, sigma2, nu)
	lh = logh(n, mu, sigma2, nu, m, V, a, d)
	lkp = sum(lA) + lh
	return(lkp)
}

# Gráficos dos intervalos de massa probabilística para cada parâmetro do
# núcleo da distribuição "a posteriori", fixados os demais, após algumas
# tentativas anteriores para redução dos limites do gráfico e melhor vi-
# sualização da curva (figuras 2a a 2c):

mu_sup=seq(10.8, 11.2, 0.001); t_mu=length(mu_sup); kp_mu=numeric(t_mu)

for(i in 1:t_mu) {
	kp_mu[i] = exp(logkpost(X=sam,
	mu=mu_sup[i], sigma2=s2, nu=nu, m=m, V=V, a=a, d=d))
	}
plot(mu_sup, kp_mu, type="l", main="",
     xlab=expression(paste(mu)), ylab="")

s2_sup=seq(0.4, 0.8, 0.001); t_s2=length(s2_sup); kp_s2=numeric(t_s2)

for(i in 1:t_s2) {
	kp_s2[i] = exp(logkpost(X=sam,
	mu=mu, sigma2=s2_sup[i], nu=nu, m=m, V=V, a=a, d=d))
	}
plot(s2_sup, kp_s2, type="l", main="",
	 xlab=expression(paste(sigma^2)), ylab="")

nu_sup=seq(0.1, 0.3, 0.001); t_nu=length(nu_sup); kp_nu=numeric(t_nu)

for(i in 1:t_nu) {
	kp_nu[i] = exp(logkpost(X=sam,
	mu=mu, sigma2=s2, nu=nu_sup[i], m=m, V=V, a=a, d=d))
	}
plot(nu_sup, kp_nu, type="l", main="",
     xlab=expression(paste(nu)), ylab="")
\end{verbatim}

\subsection*{O Método da Quadratura de Riemann}

\begin{verbatim}

# Cenários considerados, variando no número de subintervalos utilizados:

L1 = 15; L2 = 50; L3 = 100

# Tamanhos dos subintervalos, dada a combinação de cenário e parâmetro, e
# grades definidas pelos mesmos:

mu_step1 = (11.13 - 10.85)/L1; mu_gr1 = seq(10.85, 11.13, mu_step1)
mu_step2 = (11.13 - 10.85)/L2; mu_gr2 = seq(10.85, 11.13, mu_step2)
mu_step3 = (11.13 - 10.85)/L3; mu_gr3 = seq(10.85, 11.13, mu_step3)

s2_step1 = (0.78 - 0.48)/L1; s2_gr1 = seq(0.48, 0.78, s2_step1)
s2_step2 = (0.78 - 0.48)/L2; s2_gr2 = seq(0.48, 0.78, s2_step2)
s2_step3 = (0.78 - 0.48)/L3; s2_gr3 = seq(0.48, 0.78, s2_step3)

nu_step1 = (0.26 - 0.13)/L1; nu_gr1 = seq(0.13, 0.26, nu_step1)
nu_step2 = (0.26 - 0.13)/L2; nu_gr2 = seq(0.13, 0.26, nu_step2)
nu_step3 = (0.26 - 0.13)/L3; nu_gr3 = seq(0.13, 0.26, nu_step3)

# Combinando as três grades unidimensionais em cada cenário, todas com
# número igual de subintervalos e de pontos (nos limites dos interval-
# os) para integração numérica:

grid_tri1 = cbind(mu_gr1, s2_gr1, nu_gr1); l1 = nrow(grid_tri1)
grid_tri2 = cbind(mu_gr2, s2_gr2, nu_gr2); l2 = nrow(grid_tri2)
grid_tri3 = cbind(mu_gr3, s2_gr3, nu_gr3); l3 = nrow(grid_tri3)

# Produto triplo dos tamanhos dos subintervalos em cada cenário:

prod_step1 = mu_step1*s2_step1*nu_step1
prod_step2 = mu_step2*s2_step2*nu_step2
prod_step3 = mu_step3*s2_step3*nu_step3

# Cálculo do inverso da constante de proporcionalidade em cada cenário:

cprop = function(l, X, mgr, s2gr, ngr, prst, m, V, a, d) {
	c = 0
	for (i in 1:l) {
		for (j in 1:l) {
			for (k in 1:l) {
				aux = logkpost(X, mgr[i], s2gr[j], ngr[k], m, V, a, d)
				c = c + exp(aux)*prst
			}
		}
	}
	return(c)
}

c1 = cprop(l=l1, X=sam, mgr=mu_gr1, s2gr=s2_gr1, ngr=nu_gr1,
		   prst=prod_step1, m=m, V=V, a=a, d=d)
c2 = cprop(l=l2, X=sam, mgr=mu_gr2, s2gr=s2_gr2, ngr=nu_gr2,
		   prst=prod_step2, m=m, V=V, a=a, d=d)
c3 = cprop(l=l3, X=sam, mgr=mu_gr3, s2gr=s2_gr3, ngr=nu_gr3,
		   prst=prod_step3, m=m, V=V, a=a, d=d)
c1; c2; c3

# Cálculo das densidades "a posteriori" marginais em cada cenário, com
# uso do produto duplo dos tamanhos dos subintervalos em cada cenário:

pr1_dup12 = mu_step1*s2_step1
pr1_dup13 = mu_step1*nu_step1
pr1_dup23 = s2_step1*nu_step1
\end{verbatim}

\newpage

\begin{verbatim}
pr2_dup12 = mu_step2*s2_step2
pr2_dup13 = mu_step2*nu_step2
pr2_dup23 = s2_step2*nu_step2

pr3_dup12 = mu_step3*s2_step3
pr3_dup13 = mu_step3*nu_step3
pr3_dup23 = s2_step3*nu_step3

postmu_quarie = function(l, X, mgr, s2gr, ngr, prst, m, V, a, d, c) {
	postmu = numeric(l)
	for (i in 1:l) {
		postconj = 0
		for (j in 1:l) {
			for(k in 1:l) {
				aux = logkpost(X, mgr[i], s2gr[j], ngr[k], m, V, a, d)
				postconj = postconj + exp(aux)*prst
			}
		}
		postmu[i] = postconj/c
	}
	return(postmu)
}

pmq1 = postmu_quarie(l=l1, X=sam, mgr=mu_gr1, s2gr=s2_gr1, ngr=nu_gr1,
					 prst=pr1_dup23, m=m, V=V, a=a, d=d, c=c1)
pmq2 = postmu_quarie(l=l2, X=sam, mgr=mu_gr2, s2gr=s2_gr2, ngr=nu_gr2,
					 prst=pr2_dup23, m=m, V=V, a=a, d=d, c=c2)
pmq3 = postmu_quarie(l=l3, X=sam, mgr=mu_gr3, s2gr=s2_gr3, ngr=nu_gr3,
					 prst=pr3_dup23, m=m, V=V, a=a, d=d, c=c3)

plot(mu_gr1,pmq1,type="l",main="",xlab=expression(paste(mu)),ylab="")
plot(mu_gr2,pmq2,type="l",main="",xlab=expression(paste(mu)),ylab="")
plot(mu_gr3,pmq3,type="l",main="",xlab=expression(paste(mu)),ylab="")

posts2_quarie = function(l, X, mgr, s2gr, ngr, prst, m, V, a, d, c) {
	posts2 = numeric(l)
	for (i in 1:l) {
		postconj = 0
		for (j in 1:l) {
			for(k in 1:l) {
				aux = logkpost(X, mgr[j], s2gr[i], ngr[k], m, V, a, d)
				postconj = postconj + exp(aux)*prst
			}
		}
		posts2[i] = postconj/c
	}
	return(posts2)
}

\end{verbatim}

\newpage

\begin{verbatim}
psq1 = posts2_quarie(l=l1, X=sam, mgr=mu_gr1, s2gr=s2_gr1, ngr=nu_gr1,
					 prst=pr1_dup13, m=m, V=V, a=a, d=d, c=c1)
psq2 = posts2_quarie(l=l2, X=sam, mgr=mu_gr2, s2gr=s2_gr2, ngr=nu_gr2,
					 prst=pr2_dup13, m=m, V=V, a=a, d=d, c=c2)
psq3 = posts2_quarie(l=l3, X=sam, mgr=mu_gr3, s2gr=s2_gr3, ngr=nu_gr3,
					 prst=pr3_dup13, m=m, V=V, a=a, d=d, c=c3)

plot(s2_gr1, psq1, type="l", main="", xlab=expression(paste(sigma^2)),
	 ylab="")
plot(s2_gr2, psq2, type="l", main="", xlab=expression(paste(sigma^2)),
	 ylab="")
plot(s2_gr3, psq3, type="l", main="", xlab=expression(paste(sigma^2)), 
	 ylab="")

postnu_quarie = function(l, X, mgr, s2gr, ngr, prst, m, V, a, d, c) {
	postnu = numeric(l)
	for (i in 1:l) {
		postconj = 0
		for (j in 1:l) {
			for(k in 1:l) {
				aux = logkpost(X, mgr[j], s2gr[k], ngr[i], m, V, a, d)
				postconj = postconj + exp(aux)*prst
			}
		}
		postnu[i] = postconj/c
	}
	return(postnu)
}

pnq1 = postnu_quarie(l=l1, X=sam, mgr=mu_gr1, s2gr=s2_gr1, ngr=nu_gr1,
					 prst=pr1_dup12, m=m, V=V, a=a, d=d, c=c1)
pnq2 = postnu_quarie(l=l2, X=sam, mgr=mu_gr2, s2gr=s2_gr2, ngr=nu_gr2,
					 prst=pr2_dup12, m=m, V=V, a=a, d=d, c=c2)
pnq3 = postnu_quarie(l=l3, X=sam, mgr=mu_gr3, s2gr=s2_gr3, ngr=nu_gr3,
					 prst=pr3_dup12, m=m, V=V, a=a, d=d, c=c3)

plot(nu_gr1,pnq1,type="l",main="",xlab=expression(paste(nu)),ylab="")
plot(nu_gr2,pnq2,type="l",main="",xlab=expression(paste(nu)),ylab="")
plot(nu_gr3,pnq3,type="l",main="",xlab=expression(paste(nu)),ylab="")

# Cálculo da média, variância, assimetria e curtose "a posteriori" para
# cada parâmetro:

stat_post = function(gr, marg, prst) {
	media = 0
	var = 0
	assim = 0
	cur = 0
	l = length(gr)
	
	aux1 = sum(gr*marg*prst)     # Aproxima 1º momento.
	aux2 = sum((gr^2)*marg*prst) # Aproxima 2º momento.
	aux3 = sum((gr^3)*marg*prst) # Aproxima 3º momento.
	aux4 = sum((gr^4)*marg*prst) # Aproxima 4º momento.
	
	media = aux1
	var = aux2 - (media)^2
	assim = (aux3 - 3*media*var - media^3)/(var^(3/2))
	cur = (aux4 - 4*media*aux3 + 6*media^2*aux2 - 3*(media^4))/(var^2)
	return(list(media, var, assim, cur))
}

stat_post(mu_gr1, pmq1, mu_step1)
stat_post(mu_gr2, pmq2, mu_step2)
stat_post(mu_gr3, pmq3, mu_step3)

stat_post(s2_gr1, psq1, s2_step1)
stat_post(s2_gr2, psq2, s2_step2)
stat_post(s2_gr3, psq3, s2_step3)

stat_post(nu_gr1, pnq1, nu_step1)
stat_post(nu_gr2, pnq2, nu_step2)
stat_post(nu_gr3, pnq3, nu_step3)

\end{verbatim}

\subsection*{O Método da Reamostragem Por Importância Sequencial (SIR)}

\begin{verbatim}
a
\end{verbatim}

\subsection*{O Método de Monte Carlo via Cadeias de Markov (MCMC)}

\begin{verbatim}
a
\end{verbatim}

\end{document}